#!/usr/bin/env python3
# ver 0.1 - coding python by Hyuntae Jung on 2/10/2017

import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.ArgumentDefaultsHelpFormatter, 
	description='Generate angle, dihedral, and pairs from bond info. generated by gen-peg-bond.py')
## args
parser.add_argument('-i', '--input', nargs='?', 
	help='input file for bond info. (first line has total atoms, then "index (space) index" in next line')
parser.add_argument('-o', '--output', default='ang-dih.pair', nargs='?', 
	help='output file for ang, dih, and pairs of one molecule for Gromacs topology')
parser.add_argument('-v', '--version', action='version', version='%(prog)s 0.1')
# read args
args = parser.parse_args()
# default for args
args.output = args.output if args.output is not None else 'bond.pair'

## Check arguments for log
print("===============================")
print("input filename = ", args.input)
print("output filename = ", args.output)

## Read data
try:
	xvg = open(args.input, 'r')
except IOError:
	print("Problem with opening ",args.input)
	exit()
data = []
i = 0
import numpy as np
for line in xvg:
	line = line.strip()
	if not line or line.startswith('[') or line.startswith(';') \
		or line.startswith('#') or line.startswith('@'): 
		# line is blank or comment line
		continue
	bond = line.split() # store first atom in bond[0] and second atom in bond[1]

	# get total number of atoms to make nodes
	if i == 0:
		try:
			natoms = int(bond[0])
		except ValueError:
			raise ValueError("First line should be integer-type for #atoms")
		i = 1
		try:
			print(bond[1])
			raise ValueError("First line has only one integer value for #atoms")
		except IndexError:
			print("Pass the top line in input file")

		print("Warning: we assuem atom index is starting from 1, not zero.")
		print("and an atom can bond with at most 4 atoms")
		
		# make an array with [ [0,0,0,0], [0,0,0,0],...] 
		# format: [4,8,2,-1] means that index 5th atom has 3 bonds with 4th, 8th, and 2nd atom.
		info_size = 4
		bond_array = np.zeros((natoms,info_size),dtype=np.int_)
		bond_array -= 1
	
	# read data to update bond info.
	else:
		atom1 = int(bond[0]) - 1 # to start index from 0
		atom2 = int(bond[1]) - 1 # to start_index from 0
		
		# for atom1
		for index in range(info_size):
			if bond_array[atom1][index] != -1: # already stored info
				continue 
			else: # empty
				#print("1atom1 %d atom2 %d index %d" %(atom1,atom2,index))
				bond_array[atom1][index] = atom2
				break
		if index == info_size:
			raise ValueError("You seems to have %d or more bonds on an atom1. Check inputfile!" % info_size)
		
		# for atom2
		for index in range(info_size):
			if bond_array[atom2][index] != -1: # already stored info
				continue 
			else: # empty
				#print("2atom1 %d atom2 %d index %d" %(atom1,atom2,index))
				bond_array[atom2][index] = atom1
				break
		if index == info_size:
			raise ValueError("You seems to have %d or more bonds on an atom2. Check inputfile!" % info_size)
		
## make angle, dihedral, and pairs using bond_array information
# make all possible angles. it has many duplicates
#print(bond_array)
angle_array = []
dih_array = []
for atom1 in range(natoms):
	
	#print("for loop: atom1 %d" %atom1)
	list1 = bond_array[atom1]
	#print(list1)

	for atom2 in list1:
		# check condition
		if atom2 == -1: # empty
			break
		else:
			list2 = bond_array[atom2]

		for atom3 in list2:
			# check condition
			if atom3 == -1: # empty
				break
			elif atom3 == atom1: # it is not angle
				continue
			else: # update angle info
				angle_array = np.append(angle_array,[atom1, atom2, atom3])
				list3 = bond_array[atom3]
			
			for atom4 in list3:
				if atom4 == -1: # empty
					break
				elif atom4 == atom1 or atom4 == atom2: # avoid non-logical angles
					continue
				else:
					dih_array = np.append(dih_array,[atom1, atom2, atom3, atom4])

# remove duplicates (reverse sequencing)
#print(angle_array)
nangles = int(angle_array.size/3)
for iangle in range(nangles):
	atom1 = angle_array[iangle*3]
	atom2 = angle_array[iangle*3+1]
	atom3 = angle_array[iangle*3+2]
	for jangle in range(iangle+1,nangles):
		if atom3 == angle_array[jangle*3] and atom2 == angle_array[jangle*3+1] \
		and atom1 == angle_array[jangle*3+2]:
			angle_array[jangle*3] = -1
			angle_array[jangle*3+1] = -1
			angle_array[jangle*3+2] = -1
ndihs = int(dih_array.size/4)
for idih in range(ndihs):
	atom1 = dih_array[idih*4]
	atom2 = dih_array[idih*4+1]
	atom3 = dih_array[idih*4+2]
	atom4 = dih_array[idih*4+3]
	for jdih in range(idih+1,ndihs):
		if  atom4 == dih_array[jdih*4] \
		and atom3 == dih_array[jdih*4+1] \
		and atom2 == dih_array[jdih*4+2] \
		and atom1 == dih_array[jdih*4+3]:
			dih_array[jdih*4]   = -1
			dih_array[jdih*4+1] = -1
			dih_array[jdih*4+2] = -1
			dih_array[jdih*4+3] = -1
angle_array += 1
dih_array += 1

# save data
#print(angle_array)
with open(args.output, 'w') as output_file:
	output_file.write("[ pairs ] \n")
	output_file.write(";  ai    aj  funct\n")
	ndihs = int(dih_array.size/4)
	for idih in range(ndihs):
		if dih_array[idih*4] != 0:
			output_file.write(" %d   %d  1\n" %(dih_array[idih*4],dih_array[idih*4+3]))
	output_file.write("\n\n")		
	output_file.write("[ angles ] \n")
	output_file.write(";  ai    aj    ak funct \n")
	nangles = int(angle_array.size/3)
	for iangle in range(nangles):
		if angle_array[iangle*3] != 0:
			output_file.write(" %d   %d   %d   1\n" 
				%(angle_array[iangle*3],angle_array[iangle*3+1],angle_array[iangle*3+2]))
	output_file.write("\n\n")
	output_file.write("[ dihedrals ] \n")
	output_file.write(";  ai    aj    ak    al funct \n")
	ndihs = int(dih_array.size/4)
	for idih in range(ndihs):
		if dih_array[idih*4] != 0:
			output_file.write(" %d   %d   %d   %d   3\n" 
				%(dih_array[idih*4],dih_array[idih*4+1],dih_array[idih*4+2],dih_array[idih*4+3]))
print("Finish!")





		
				



