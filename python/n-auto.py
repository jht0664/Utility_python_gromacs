#!/usr/bin/env python3
# ver 0.1 - coding python by Hyuntae Jung on  2/11/2017

import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.ArgumentDefaultsHelpFormatter, 
	description='2D Delta_number autocorrelation for selected molecules')
## args
parser.add_argument('-i', '--input', default='traj.trr', nargs='?', 
	help='input trajectory file')
parser.add_argument('-s', '--structure', default='topol.tpr', nargs='?', 
	help='.tpr structure file')
parser.add_argument('-select', '--select', nargs='?', 
	help='a file with a command-line for select_atoms in MDAnalysis')
parser.add_argument('-nbin', '--nbin', nargs='?', 
	help='number of bins, otherwise we use the bin size')
parser.add_argument('-tol', '--tol', default=0.0, nargs='?', 
	help='tolerance for block average (> 0 and < 1). (recommend 0.4 - 0.5) if 0, no block average')
parser.add_argument('-axis', '--axis', default=2, nargs='?', 
	help='which axis for histogram (x axis (0), y axis (1), z axis (2))')
parser.add_argument('-odnum', '--odnum', default='traj.dnum', nargs='?', 
	help='output file for delta_number trajectory')
parser.add_argument('-odnumc', '--odnumc', default='traj.dnumc', nargs='?', 
	help='output file for 2D delta_number autocorrelation')
parser.add_argument('-v', '--version', action='version', version='%(prog)s 0.1')
# read args
args = parser.parse_args()
# default for args
args.input = args.input if args.input is not None else 'traj.trr'
args.structure = args.structure if args.structure is not None else 'topol.tpr'
args.odnum = args.odnum if args.odnum is not None else 'traj.dnum'
args.odnumc = args.odnumc if args.odnumc is not None else 'traj.dnumc'
args.axis = args.axis if args.axis is not None else 2
args.axis = int(args.axis)
args.nbin = int(args.nbin)
args.tol = args.tol if args.tol is not None else 0.0
args.tol = float(args.tol)

## Check arguments for log
print("===============================")
print("input filename   = ", args.input)
print("str filename     = ", args.structure)
if args.select is not None:
	print("select filename  = ", args.select)
print("number of bins   = ", args.nbin)
if args.tol != 0.0:
	print("tolerance for block average = ", args.tol)
print("axis [0:2]       = ", args.axis)
print("output concentration trajectory = ", args.odnum)
print("output conc. fluctuation = ", args.odnumc)

## check vaulable setting
if args.nbin < 10:
	raise ValueError("Too small nbin is usually not valid. (recommend > 10)")
if args.axis < 0 or args.axis > 2:
	raise ValueError("wrong input of axis for histogram")
if args.tol >= 1.0 or args.tol < 0.0:
	raise ValueError("tolerance is not accepted due to the value, %f" %args.tol)

## timer
import time
start_clock = time.clock() # process time
start_wall = time.time() # wall time

## import modules
import hjung
from hjung import *
import numpy as np
from scipy import ndimage

## read a topology and a trajectory using module MDAnalysis with selection
print("="*30)
coordinates, unit_cells = hjung.io.read_coord_trr_3d(args.structure, args.input, args.select)
print("Done: reading trajectory and topology file")

## reduce 3d-coordinates to 1d-coordinates
coordinates_1d = coordinates[:,:,args.axis]
unit_cells_1d = unit_cells[:,args.axis]

## number histograms for each frame 
print("="*30)
number_t_1d, bin_t_1d = hjung.analyze.histo_t_1d_nbin(coordinates_1d, unit_cells_1d, args.nbin) 
print("Done: making number trajectory with respect to bins")

## block average to get stable volume (or number density)
block_length = 1
if args.tol > 0:
	print("="*30)
	print("To optimize, we use unit cell length on the axis you select.")
	block_length = hjung.analyze.opt_block_length_1d(unit_cells_1d,args.tol) 
	print("Done: optimize block length")
if block_length > 1:
	print("="*30)
	number_t_1d = hjung.analyze.block_average_1d(number_t_1d,block_length) 

## save number histogram trajectory
#print("===============================")
#import numpy as np
#np.savetxt('traj.numb', number_t_1d, fmt='%f')
#print("Finished saving files of number and bin trajectory")

## Calculate delta_number, N[j-th frame, i-th slab] - <N>
# Assume: total #particle in a frame is fixed. (No particle incertion or deletion during simulation)
print("="*30)
ref_avg = np.mean(number_t_1d[0])
delta_number_t_1d = number_t_1d - ref_avg
np.savetxt(args.odnum, delta_number_t_1d, 
	header='avg.number = %f, block_length = %d, generated by Hyuntae python code' %(ref_avg,block_length), fmt='%f', comments='# ')
print("Finished saving a file of delta_number trajectory")

## 2D autocorrelation function with periodic box system
# \Delta N(i,{ t }_{ 1 })\ast \Delta N(j,{ t }_{ 2 })
# i.e. \Delta N(r)=N(r)-\left< c \right>  This is what we did previous step
# assume time trajectory is periodic
print("="*30)
autocorr_2d = ndimage.correlate(delta_number_t_1d,delta_number_t_1d,mode='wrap') 
np.savetxt(args.odnumc, autocorr_2d, 
	header='2D autocorrelation autocorr(i,t) for delta_number, avg.number = %f, block_length = %d, generated by Hyuntae python code' 
	%(ref_avg,block_length), fmt='%f', comments='# ')
print("Finished saving a file of delta_number autocorrelation 2D")
print("When you plot autocorrelation, remember that x- and y-range [-half:half]")

print("===============================")
print(time.clock() - start_clock, "seconds process time")
print(time.time() - start_wall, "seconds wall time")