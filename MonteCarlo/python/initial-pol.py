#!/usr/bin/env python3
# ver 0.1 - coding python by Hyuntae Jung on  6/1/2017

import argparse
parser = argparse.ArgumentParser(
	formatter_class=argparse.ArgumentDefaultsHelpFormatter, 
	description='Initial coordiante of FRP (freely rotated poymer, no angle potential) for MC or MD simulation')
## args
#parser.add_argument('-i', '--input', default='init.ic', nargs='?', 
#	help='input file')
parser.add_argument('-na', '--nmola', nargs='?', type=int,
	help='# A molecules')
parser.add_argument('-ma', '--mona', nargs='?', type=int,
	help='degree of polymerization of A chains')
parser.add_argument('-nb', '--nmolb', nargs='?', type=int,
	help='# B molecules')
parser.add_argument('-mb', '--monb', nargs='?', type=int,
	help='degree of polymerization of B chains')
parser.add_argument('-r', '--ratio', default=5.0, nargs='?', type=float,
	help='ratio of box-z/box-x (box-x = box-y)')
parser.add_argument('-sep', '--sep', default="YES", nargs='?', type=str,
        help='pre-separation YES/NO')
parser.add_argument('-fr', '--frac', default=1.0, nargs='?', type=float,
	help='number fraction of A beads of one phase if -sep YES')
parser.add_argument('-seed', '--seed', default=1985, nargs='?', type=int,
	help='random seed')
parser.add_argument('-d', '--dens', nargs='?', type=float,
	help='number density of monomers')
parser.add_argument('-scale', '--scale', nargs='?', default=1.25, type=float,
	help='box scale on z-direction to accelate or reduce insertion process')
parser.add_argument('-sa', '--sizea', default=1.0, nargs='?', type=float,
	help='diameter of A')
parser.add_argument('-sb', '--sizeb', default=1.0, nargs='?', type=float,
	help='diameter of B')
parser.add_argument('-fm', '--format', default='GRO', nargs='?', 
	help='Save in fortran MC format (MC), .npz format (NPZ), or .gro format (GRO)')
parser.add_argument('-o', '--output', default='init', nargs='?', 
	help='output file (exclude extension name) ')
parser.add_argument('args', nargs=argparse.REMAINDER)
parser.add_argument('-v', '--version', action='version', version='%(prog)s 0.1')
# check args
args = parser.parse_args()
print(" input arguments: {0}".format(args))
if args.sep != 'YES' and args.sep != 'NO':
	print(args.sep)
	raise ValueError("Wrong argument for pre-separation option")
if args.sep == 'NO' and args.frac != 1.0:
	raise ValueError("-sep and -fr not matched or not set")
if args.sep == 'YES':
	if args.nmola != args.nmolb:
		raise ValueError("Not support the different #particles of A and B")
if args.format != 'MC' and args.format != 'NPZ' and args.format != 'GRO':
	raise ValueError("Wrong argument for format!")
if args.format == 'MC':
	args.output = args.output+'.ic'
elif args.format == 'NPZ':
	args.output = args.output+'.npz'
elif args.format == 'GRO':
	args.output = args.output+'.gro'

## import 
import numpy as np
import sys
sys.path.append('/home/hjung52/Utility/python/')
import hjung
from hjung import *

## timer
start_proc, start_prof = hjung.time.init()

## determine box size
nctot = args.nmola + args.nmolb
nmtot_a = args.nmola * args.mona
nmtot_b = args.nmolb * args.monb
nmtot = nmtot_a + nmtot_b
print("Total #chains = %s" %nctot)
print("Total #monomers = %s" %nmtot)
box = hjung.initial.lj_box_init_w_ndens_ratio(nmtot, args.dens, [1.0, 1.0, args.ratio])

# accelate insertion process by reduing density.
box[2] = box[2] * args.scale

## lattice insertion process
if args.sizea != args.sizea:
	raise RuntimeError("sorry, different size of components case not supported yet.")
# guess lattice (cubic) cell length 
cell_length = max(args.sizea,args.sizeb)
# coordinates, "np.zeros((nmtot, 3))"
coordinates = hjung.initial.insertion_lattice_sep(args.nmola, args.mona, args.nmolb, args.monb, cell_length, box, args.frac, args.seed)

# save initial coordinates
print("="*30)
print("Saving OutputFile...")
# if exist already, rename the file
hjung.io.rename_existing_file(args.output)
if args.format == 'NPZ':
	# NPZ: python binary file format
	# array_argument = nmola, nmolb, coord, box
	np.savez(args.output,nmola=args.nmola,nmolb=args.nmolb,coord=coordinates,box=box)
elif args.format == 'GRO':
	# GRO: gromacs file format
	output_file = open(args.output, 'w')
	output_file.write("generated by initial-pol.py\n")
	output_file.write(" %d\n" %(nmtot))
	imol = 0
	i = 0
	while imol < nctot:
		#print("hello, imol {0}".format(imol))
		if imol < args.nmola:
			atom_name = "A"
			for iatom in range(args.mona):
				#print("hello, A {0}".format(i))
				if iatom == 0 or iatom == args.mona - 1:
					res_name = atom_name + "E" # AE or BE
				else:
					res_name = atom_name + "M" # AM or BM
				output_file.write('{0:5d}{1:<5s}{2:5s}{3:5d}{4:8.3f}{5:8.3f}{6:8.3f}\n'.format(
					(iatom+1)%100000,res_name,atom_name,(i+1)%100000,coordinates[i][0],coordinates[i][1],coordinates[i][2]))
				i += 1	
		else:
			atom_name = "B"
			for iatom in range(args.mona):
				#print("hello, B {0}".format(i))
				if iatom == 0 or iatom == args.mona - 1:
					res_name = atom_name + "E" # AE or BE
				else:
					res_name = atom_name + "M" # AM or BM
				output_file.write('{0:5d}{1:<5s}{2:5s}{3:5d}{4:8.3f}{5:8.3f}{6:8.3f}\n'.format(
					(iatom+1)%100000,res_name,atom_name,(i+1)%100000,coordinates[i][0],coordinates[i][1],coordinates[i][2]))
				i += 1
		imol += 1	
	if i != nmtot:
		raise RuntimeError(" not match total # particles.")
	output_file.write('{0:10.5f}{1:10.5f}{2:10.5f}\n'.format(box[0],box[1],box[2]))
	output_file.close()
elif args.format == 'MC':
	raise RuntimeError(" not supported yet.")
	# fortran MC version 'composite.ic'
	output_file = open(args.output, 'w')
	output_file.write('{}  #NUMBER OF B particle \n'.format(args.nmolb))
	output_file.write('{}  #NUMBER OF A particle \n'.format(args.nmola))
	output_file.write('{}  #SIZE OF B \n'.format(args.sizeb))
	output_file.write('{}  #SIZE OF A \n'.format(args.sizea))
	output_file.write('{} {} {}  # BOX SIZE \n'.format(box[0],box[1],box[2]))
	# coordinates of A, then B
	for i in range(ntot):
		output_file.write('{} {} {} {} {}\n'.format(i,i,coordinates[i][0],coordinates[i][1],coordinates[i][2]))
	output_file.close()
else:
	raise RuntimeError("Sometime wrong!")

## timer
hjung.time.end_print(start_proc, start_prof)